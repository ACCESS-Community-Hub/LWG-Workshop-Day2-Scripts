# This script makes the necessary modifications to the NetCDF file generated by
# xconv to allow the file to be used by CABLE as a gridinfo file.

import netCDF4
import numpy

TYPEMAP = {
    numpy.dtype('float32'): 'f4',
    numpy.dtype('float64'): 'f8',
    numpy.dtype('int8'): 'i1',
    numpy.dtype('int16'): 'i2',
    numpy.dtype('int32'): 'i4',
    numpy.dtype('int64'): 'i8',
    numpy.dtype('uint8'): 'u1',
    numpy.dtype('uint16'): 'u2'
    }

def add_metadata(OutDataset, attribs):
    """Add the specified attributes to the output dataset.

    Inputs:
    OutDataset: New NCDataset to write to.
    attribs: Dictionary of attributes to add to the NCDataset.
    """

    for k, v in attribs.items():
        OutDataset.setncattr(k, v)

def add_dimensions(InDataset, OutDataset, DimensionMap, ExtraDims = {}):
    """Add the specified dimensions from InDataset to OutDataset using the
    supplied DimensionMap. DimensionMap specifies which dimensions to take
    from the original dataset and what names to change them to.

    Inputs:
    InDataset: Original NCDataset to take the dimensions from.
    OutDataset: New NCDataset to write to.
    DimensionMap: Dictionary of oldDim: newDim pairs.
    ExtraDims: {name: length} dictionary for any extra dimensions to add to the
        NCDataset. Defaults to {}.
    """

    for oldName, newName in DimensionMap.items():
        OutDataset.createDimension(newName, len(InDataset.dimensions[oldName]))

    for newName, newLength in ExtraDims.items():
        OutDataset.createDimension(newName, newLength)

def convert_variable(InDataset,
                    OutDataset,
                    OrigVar,
                    NewVar,
                    mapper = None,
                    dims = None,
                    attribs = {}):
    """Use the OrigVar NetCDF variable in InNCDataset to create variable NewVar
    in OutDataset.
    Can optionally provide a mapping function to convert the original data.
    Data will be squeezed (any length-1 dimensions removed) if no mapping is
    provided. 

    Unless otherwise specified, the new dimensions attached to the variable
    will be the original dimensions minus any length one dimensions.

    Inputs:
        InNCDataset: Original NCDataset or dictionary of named NCDatasets to
            use as the source data.
        OutNCDataset: New NCDataset to write to.
        OrigVar: Original name or dictionary of names of the variable(s) in the
            InNCDataset(s).
        NewVar: New name for the variable in NCDataset.
        mapper: Mapping function to process the original data, default None.
            A NetCDF4.Variable is passed to the mapping function.
            Mapping must return an array.
        dims: Dimension tuple for the variable, default is inferred from the 
            original data.
        attribs: Any attributes to add. Defaults to empty dict.
    """

    # Give an update on where we're up to
    print(f"Converting {NewVar}")

    # Here we dispatch to either convert_many_to_one if the InDataset is a
    # dictionary, otherwise dispatch to convert_one_to_one.
    if isinstance(OrigVar, dict):
        newDims, NewData = convert_many_to_one(
                InDataset,
                OrigVar,
                mapper,
                dims
                )
    else:
        newDims, NewData = convert_one_to_one(
                InDataset,
                OrigVar,
                mapper,
                dims
                )

    # Now we've created the new data, we can add it to the dataset
    # Create the variable in the new Dataset
    OutDataset.createVariable(
            NewVar,
            TYPEMAP[NewData.dtype],
            newDims,
            fill_value = getattr(NewData, "fill_value", 2e20)
            )

    # Assign the data
    OutDataset[NewVar][:] = NewData

    # Assign the metadata
    # Set the attributes, with a merge of the original attributes and user spec
    for k, v in attribs.items():
        OutDataset[NewVar].setncattr(k, v)


def convert_one_to_one(InDataset,
                       OrigVar,
                       mapper,
                       dims,
                       ):

    """Do a one-to-one conversion from an input variable to an output variable.
    """

    # First, check the dimensions of the original variable
    # Can't trust the len(Dataset.dimensions(dim)) because of potential
    # unlimited dimensions
    OrigData = InDataset[OrigVar]
    newDims = tuple(dim for (dim, dimlength) in
            zip(OrigData.dimensions, OrigData.shape) if dimlength > 1)

    # Write over the default if dims is provided
    newDims = dims if dims else newDims

    # Optionally pass it to the mapper
    if mapper:
        NewData = mapper(OrigData)
    else:
        # Just squeeze it
        NewData = OrigData[:].squeeze()

    return newDims, NewData

def convert_many_to_one(InDataset,
                        OrigVar,
                        mapper,
                        dims,
                        ):
    """Perform a many-to-one conversion from a series of input variables to a
    single output variable."""

    if (not dims):
        raise ValueError('Need to provide dimensions for a many-to-one ' +\
                'mapping.')
    
    # Pass the input data and variable dictionaries to the mapper
    NewData = mapper(InDataset, OrigVar)

    return dims, NewData

def add_variable(OutDataset,
                 NewVar,
                 Data,
                 dims = None,
                 attribs = {}
                 ):
    """Add the OutDataset variable OutVar with the given Data. If dims is not
    given, then it will be inferred from the dimensions of the given Data.
    Supplied attribs are applied to the variable.

    Inputs:
    OutDataset: NCDataset to write to.
    NewVar: Name of the NCVariable to attach to the NCDataset.
    Data: Array of data to attach to the NCVariable.
    attribs: Dictionary of attributes to add to the NCVariable.
    """

    # For now, just take the dims as is
    OutDataset.createVariable(
            NewVar,
            TYPEMAP[Data.dtype],
            Data.dims,
            fill_value = getattr(Data, "fill_value", 2e20)
            )

    # Apply the data
    OutDataset[NewVar][:] = Data

    # Apply the metadata
    for k, v in attribs.items():
        setattr(OutDataset[NewVar], k, v)
